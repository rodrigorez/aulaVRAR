<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Teste 4 - Dispositivos Muito Fracos</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <style>
        #fps {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            font-family: Arial;
            font-size: 16px;
            z-index: 1000;
            border-radius: 5px;
        }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            font-family: Arial;
            font-size: 14px;
            z-index: 1000;
            border-radius: 5px;
            width: 280px;
        }
        #velocitySlider {
            width: 100%;
            margin: 10px 0;
        }
        #velocityValue {
            color: #00ff00;
            font-weight: bold;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="fps">FPS: --</div>
    <div id="controls">
        <div>Velocidade do Orb:</div>
        <input type="range" id="velocitySlider" min="0" max="5" step="0.00001" value="0.00000">
        <div>Valor: <span id="velocityValue">0.00000</span></div>
        
        <hr style="margin: 15px 0; border-color: #555;">
        
        <div>Estabilização:</div>
        <label><input type="checkbox" id="stabilizationEnabled"> Ativar</label><br>
        <div style="margin-top: 10px;">
            <div>Suavidade: <span id="smoothnessValue">0.95000</span></div>
            <input type="range" id="smoothnessSlider" min="0.1" max="0.99" step="0.00001" value="0.95000">
        </div>
        <div style="margin-top: 10px;">
            <div>Deadzone: <span id="deadzoneValue">0.05000</span></div>
            <input type="range" id="deadzoneSlider" min="0" max="0.5" step="0.00001" value="0.05000">
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #aaa;">
            α: <span id="alphaValue">--</span><br>
            β: <span id="betaValue">--</span><br>
            γ: <span id="gammaValue">--</span>
        </div>
    </div>
    
    <a-scene embedded style="height: 100vh;">
        <a-entity id="skybox"></a-entity>
        
        <!-- Quadro com foto de referência -->
        <a-plane 
            position="0 1.6 -3" 
            rotation="0 0 0" 
            width="2" 
            height="1.5" 
            material="src: https://picsum.photos/800/600; transparent: false; alphaTest: 0.5"
            geometry="primitive: plane">
            
            <!-- Moldura do quadro -->
            <a-box 
                position="0 0 -0.01" 
                width="1.05" 
                height="1.05" 
                depth="0.05" 
                material="color: #8B4513; metalness: 0.3; roughness: 0.7">
            </a-box>
        </a-plane>
    </a-scene>

    <script>
        // Shader para dispositivos muito fracos - Orb com estabilização
        const fragmentShader = `
            uniform float time;
            uniform float velocity;
            uniform vec2 deviceOrientation;
            uniform float stabilizationStrength;
            uniform vec2 resolution;
            varying vec2 vUv;

            void main() {
                vec2 uv = vUv;
                vec2 center = vec2(0.5, 0.5);
                
                float t = time * velocity;
                
                // Fundo fixo
                vec3 color = vec3(0.02, 0.01, 0.05);
                
                // Orb com movimento complexo
                vec2 orbMovement = vec2(
                    sin(t) * 0.10 + cos(t * 0.7) * 0.07,
                    cos(t * 0.4) * 0.10 + sin(t * 1.3) * 0.05
                );
                
                // Aplicar estabilização baseada na orientação
                vec2 stabilizedOffset = deviceOrientation * stabilizationStrength;
                vec2 orbPos = center + orbMovement - stabilizedOffset;
                
                float distToOrb = distance(uv, orbPos);
                
                // Orb simples
                float orb = smoothstep(0.35, 0.25, distToOrb);
                
                vec3 orbColor = vec3(0.5, 0.1, 0.7) * orb;
                
                color += orbColor;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Inicializar Three.js
        AFRAME.registerComponent('skybox-shader', {
            init: function() {
                const geometry = new THREE.SphereGeometry(500, 12, 12);
                const skyMaterial = new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: {
                        time: { value: 0 },
                        velocity: { value: 0.0 },
                        deviceOrientation: { value: new THREE.Vector2(0, 0) },
                        stabilizationStrength: { value: 0.0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                    },
                    side: THREE.BackSide
                });

                const skyMesh = new THREE.Mesh(geometry, skyMaterial);
                this.el.object3D.add(skyMesh);
                this.skyMaterial = skyMaterial;
            },
            
            tick: function(time) {
                if (this.skyMaterial) {
                    this.skyMaterial.uniforms.time.value = performance.now() * 0.001;
                }
            }
        });

        // Adicionar componente ao skybox
        const skyboxEl = document.querySelector('#skybox');
        skyboxEl.setAttribute('skybox-shader', '');

        // Controles de velocidade e estabilização
        const velocitySlider = document.getElementById('velocitySlider');
        const velocityValue = document.getElementById('velocityValue');
        const stabilizationEnabled = document.getElementById('stabilizationEnabled');
        const smoothnessSlider = document.getElementById('smoothnessSlider');
        const smoothnessValue = document.getElementById('smoothnessValue');
        const deadzoneSlider = document.getElementById('deadzoneSlider');
        const deadzoneValue = document.getElementById('deadzoneValue');
        const alphaValue = document.getElementById('alphaValue');
        const betaValue = document.getElementById('betaValue');
        const gammaValue = document.getElementById('gammaValue');
        
        let skyMaterial = null;
        
        // Sistema de estabilização híbrido
        let smoothedOrientation = { alpha: 0, beta: 0, gamma: 0 };
        let isStabilizationActive = false;
        let smoothnessFactor = 0.95;
        let deadzoneFactor = 0.05;

        // Aguardar inicialização do material
        setTimeout(() => {
            skyMaterial = skyboxEl.components['skybox-shader'].skyMaterial;
        }, 100);

        // Função de suavização híbrida
        function applySmoothingFilter(current, target, smoothness, deadzone) {
            const diff = Math.abs(target - current);
            if (diff < deadzone) return current; // Deadzone
            return current + (target - current) * (1 - smoothness); // Filtro passa-baixa
        }

        // Event listeners para controles
        velocitySlider.addEventListener('input', function() {
            const velocity = parseFloat(this.value);
            velocityValue.textContent = velocity.toFixed(5);
            if (skyMaterial) {
                skyMaterial.uniforms.velocity.value = velocity;
            }
        });

        stabilizationEnabled.addEventListener('change', function() {
            isStabilizationActive = this.checked;
            if (skyMaterial) {
                skyMaterial.uniforms.stabilizationStrength.value = isStabilizationActive ? 0.1 : 0.0;
            }
        });

        smoothnessSlider.addEventListener('input', function() {
            smoothnessFactor = parseFloat(this.value);
            smoothnessValue.textContent = smoothnessFactor.toFixed(5);
        });

        deadzoneSlider.addEventListener('input', function() {
            deadzoneFactor = parseFloat(this.value);
            deadzoneValue.textContent = deadzoneFactor.toFixed(5);
        });

        // Solicitar permissão para sensores de orientação
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission().then(permissionState => {
                if (permissionState === 'granted') {
                    window.addEventListener('deviceorientation', handleOrientation);
                }
            });
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
        }

        function handleOrientation(event) {
            if (!isStabilizationActive) return;
            
            const alpha = event.alpha || 0; // Z-axis
            const beta = event.beta || 0;   // X-axis
            const gamma = event.gamma || 0; // Y-axis
            
            // Aplicar filtros de suavização
            smoothedOrientation.alpha = applySmoothingFilter(smoothedOrientation.alpha, alpha, smoothnessFactor, deadzoneFactor);
            smoothedOrientation.beta = applySmoothingFilter(smoothedOrientation.beta, beta, smoothnessFactor, deadzoneFactor);
            smoothedOrientation.gamma = applySmoothingFilter(smoothedOrientation.gamma, gamma, smoothnessFactor, deadzoneFactor);
            
            // Atualizar displays
            alphaValue.textContent = smoothedOrientation.alpha.toFixed(2);
            betaValue.textContent = smoothedOrientation.beta.toFixed(2);
            gammaValue.textContent = smoothedOrientation.gamma.toFixed(2);
            
            // Converter para coordenadas de shader (normalizar e inverter Y)
            if (skyMaterial) {
                const normalizedX = (smoothedOrientation.gamma / 45.0); // ±45° range
                const normalizedY = -(smoothedOrientation.beta / 45.0); // Inverter Y
                skyMaterial.uniforms.deviceOrientation.value.set(normalizedX, normalizedY);
            }
        }

        // FPS Counter limitado a 30 FPS
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        let lastFrameTime = 0;
        const targetFPS = 30;
        const frameInterval = 1000 / targetFPS; // ~33.33ms

        function updateFPS() {
            const currentTime = performance.now();
            
            // Limitar a 30 FPS
            if (currentTime - lastFrameTime < frameInterval) {
                requestAnimationFrame(updateFPS);
                return;
            }
            
            lastFrameTime = currentTime;
            frameCount++;
            
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = `FPS: ${fps} (max 30)`;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            requestAnimationFrame(updateFPS);
        }

        updateFPS();
    </script>
</body>
</html>