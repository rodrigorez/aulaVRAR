<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Teste 3 - Celulares Antigos</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <style>
        #fps {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            font-family: Arial;
            font-size: 16px;
            z-index: 1000;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="fps">FPS: --</div>
    
    <a-scene embedded style="height: 100vh;">
        <a-entity id="skybox"></a-entity>
    </a-scene>

    <script>
        // Shader para celulares antigos - Orb simples
        const fragmentShader = `
            uniform float time;
            uniform vec2 resolution;
            varying vec2 vUv;

            void main() {
                vec2 uv = vUv;
                vec2 center = vec2(0.5, 0.5);
                
                float t = time * 0.05;
                
                // Fundo básico
                vec3 color = vec3(0.0);
                float noise = sin(uv.x * 4.0 + t) * sin(uv.y * 3.0 + t);
                color += vec3(0.05, 0.02, 0.1) * noise * 0.1;
                
                // Orb principal
                vec2 orbPos = center + vec2(sin(t) * 0.05, cos(t * 0.4) * 0.05);
                float distToOrb = distance(uv, orbPos);
                
                // Uma camada de brilho apenas
                float orb = smoothstep(0.3, 0.2, distToOrb);
                
                vec3 orbColor = vec3(0.6, 0.2, 0.8) * orb;
                
                // Sem pulsação para economizar processamento
                color += orbColor;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Inicializar Three.js
        AFRAME.registerComponent('skybox-shader', {
            init: function() {
                const geometry = new THREE.SphereGeometry(500, 16, 16);
                const skyMaterial = new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                    },
                    side: THREE.BackSide
                });

                const skyMesh = new THREE.Mesh(geometry, skyMaterial);
                this.el.object3D.add(skyMesh);
                this.skyMaterial = skyMaterial;
            },
            
            tick: function(time) {
                if (this.skyMaterial) {
                    this.skyMaterial.uniforms.time.value = performance.now() * 0.001;
                }
            }
        });

        // Adicionar componente ao skybox
        document.querySelector('#skybox').setAttribute('skybox-shader', '');

        // FPS Counter
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            requestAnimationFrame(updateFPS);
        }

        updateFPS();
    </script>
</body>
</html>